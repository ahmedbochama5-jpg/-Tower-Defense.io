<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù„Ø¹Ø¨Ø© Ø§Ù„Ø¯ÙØ§Ø¹ Ø¹Ù† Ø§Ù„Ø¨Ø±Ø¬ - Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡ Ø§Ù„Ø£Ø°ÙƒÙŠØ§Ø¡</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial', sans-serif;
        }

        body {
            background: linear-gradient(45deg, #1a1a2e, #16213e, #0f3460);
            color: white;
            min-height: 100vh;
            direction: rtl;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #ffd700;
        }

        .game-area {
            display: grid;
            grid-template-columns: 3fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        #gameCanvas {
            background: linear-gradient(160deg, #2d5016, #3a6632);
            border: 4px solid #5D4037;
            border-radius: 15px;
        }

        .enemy-info {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
        }

        .enemy-type {
            margin: 15px 0;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border-right: 4px solid;
        }

        .boss-warning {
            background: linear-gradient(45deg, #ff0000, #ff6b6b);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            margin: 10px 0;
            display: none;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }

        button {
            background: linear-gradient(135deg, #FF6B6B, #FFD93D);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: translateY(-2px);
        }

        .group-indicator {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸ° Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡ Ø§Ù„Ø£Ø°ÙƒÙŠØ§Ø¡ - ØªØ­Ø¯ÙŠØ§Øª Ø¬Ø¯ÙŠØ¯Ø©! ğŸ¯</h1>
            <p>Ø£Ø¹Ø¯Ø§Ø¡ ØªØªØ¬Ù†Ø¨ Ø§Ù„Ø£Ø¨Ø±Ø§Ø¬ â€¢ ØªØªØ­Ø±Ùƒ ÙÙŠ Ù…Ø¬Ù…ÙˆØ¹Ø§Øª â€¢ Ø²Ø¹Ù…Ø§Ø¡ Ø¨Ù‚Ø¯Ø±Ø§Øª Ø®Ø§ØµØ©</p>
        </header>

        <div class="game-area">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
            
            <div class="enemy-info">
                <h3>ğŸ¯ Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©</h3>
                
                <div class="enemy-type" style="border-right-color: #FF4444;">
                    <h4>ğŸ‘» Ø§Ù„Ø¹Ø¯Ùˆ Ø§Ù„Ø´Ø¨Ø­</h4>
                    <p>ÙŠØªØ¬Ù†Ø¨ Ø§Ù„Ø£Ø¨Ø±Ø§Ø¬ â€¢ Ø³Ø±Ø¹Ø© Ø¹Ø§Ù„ÙŠØ©</p>
                </div>

                <div class="enemy-type" style="border-right-color: #FFAA00;">
                    <h4>ğŸ›¡ï¸ Ø§Ù„Ø¹Ø¯Ùˆ Ø§Ù„Ø¯Ø¨Ø§Ø¨Ø©</h4>
                    <p>ØµØ­Ø© Ø¹Ø§Ù„ÙŠØ© â€¢ ÙŠØªØ­Ø±Ùƒ ÙÙŠ Ù…Ø¬Ù…ÙˆØ¹Ø§Øª</p>
                </div>

                <div class="enemy-type" style="border-right-color: #9370DB;">
                    <h4>ğŸŒ€ Ø§Ù„Ø¹Ø¯Ùˆ Ø§Ù„Ø³Ø§Ø­Ø±</h4>
                    <p>ÙŠØ¨Ø·Ø¦ Ø§Ù„Ø£Ø¨Ø±Ø§Ø¬ â€¢ ØªØ£Ø«ÙŠØ± Ø¬Ù…Ø§Ø¹ÙŠ</p>
                </div>

                <div class="enemy-type" style="border-right-color: #00FF00;">
                    <h4>ğŸƒ Ø§Ù„Ø¹Ø¯Ùˆ Ø§Ù„Ø³Ø±ÙŠØ¹</h4>
                    <p>Ø³Ø±Ø¹Ø© ÙØ§Ø¦Ù‚Ø© â€¢ ØµØ­Ø© Ù…Ù†Ø®ÙØ¶Ø©</p>
                </div>

                <div class="boss-warning" id="bossWarning">
                    âš ï¸ ØªØ­Ø°ÙŠØ±: Ø§Ù„Ø²Ø¹ÙŠÙ… Ù‚Ø§Ø¯Ù…! ğŸ‘‘
                </div>

                <div class="enemy-type" style="border-right-color: #FF0000;">
                    <h4>ğŸ‘‘ Ø§Ù„Ø²Ø¹ÙŠÙ… Ø§Ù„ØªÙ†ÙŠÙ†</h4>
                    <p>ØµØ­Ø© Ù‡Ø§Ø¦Ù„Ø© â€¢ ÙŠØ·Ù„Ù‚ Ù†ÙŠØ±Ø§Ù† â€¢ ÙŠØ¬Ø°Ø¨ Ø§Ù„Ø£Ø¨Ø±Ø§Ø¬</p>
                </div>
            </div>
        </div>

        <div class="controls">
            <button id="startWave">ğŸŒŠ Ø¨Ø¯Ø¡ Ø§Ù„Ù…ÙˆØ¬Ø©</button>
            <button id="restartGame">ğŸ”„ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø¨Ø¯Ø¡</button>
        </div>
    </div>

    <script>
        // Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const bossWarning = document.getElementById('bossWarning');

        // Ø­Ø§Ù„Ø© Ø§Ù„Ù„Ø¹Ø¨Ø©
        let gameState = {
            gold: 200,
            health: 100,
            wave: 1,
            towers: [],
            enemies: [],
            projectiles: [],
            groups: [],
            isWaveActive: false,
            enemiesInWave: 8,
            enemiesSpawned: 0,
            bossSpawned: false
        };

        // Ø§Ù„Ù…Ø³Ø§Ø±
        const path = [
            {x: 0, y: 300}, {x: 200, y: 300}, {x: 200, y: 100},
            {x: 400, y: 100}, {x: 400, y: 400}, {x: 600, y: 400},
            {x: 600, y: 200}, {x: 800, y: 200}
        ];

        // Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ø£Ø¨Ø±Ø§Ø¬ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
        const towerTypes = {
            arrow: { 
                damage: 15, 
                range: 150, 
                speed: 1000, 
                color: '#4CAF50', 
                cost: 50,
                shape: 'circle'
            },
            cannon: { 
                damage: 40, 
                range: 200, 
                speed: 2000, 
                color: '#FF5722', 
                cost: 100,
                shape: 'square'
            },
            ice: { 
                damage: 10, 
                range: 180, 
                speed: 1500, 
                color: '#87CEEB', 
                cost: 120,
                shape: 'triangle',
                slow: 0.6
            },
            poison: { 
                damage: 5, 
                range: 160, 
                speed: 3000, 
                color: '#9C27B0', 
                cost: 140,
                shape: 'hexagon',
                dot: { damage: 2, duration: 3000 }
            }
        };

        // Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
        const enemyTypes = {
            ghost: {
                health: 40,
                speed: 1.8,
                color: '#FF4444',
                gold: 15,
                behavior: 'avoid',
                radius: 12,
                shape: 'ghost'
            },
            tank: {
                health: 150,
                speed: 0.4,
                color: '#FFAA00',
                gold: 25,
                behavior: 'group',
                radius: 18,
                shape: 'tank'
            },
            mage: {
                health: 60,
                speed: 0.8,
                color: '#9370DB',
                gold: 30,
                behavior: 'mage',
                radius: 14,
                shape: 'mage'
            },
            runner: {
                health: 20,
                speed: 2.5,
                color: '#00FF00',
                gold: 10,
                behavior: 'normal',
                radius: 10,
                shape: 'runner'
            },
            boss: {
                health: 500,
                speed: 0.3,
                color: '#FF0000',
                gold: 100,
                behavior: 'boss',
                radius: 25,
                shape: 'dragon'
            }
        };

        // ÙØ¦Ø© Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©
        class Group {
            constructor() {
                this.members = [];
                this.center = { x: 0, y: 0 };
                this.color = `hsl(${Math.random() * 360}, 70%, 50%)`;
            }

            addMember(enemy) {
                this.members.push(enemy);
                enemy.group = this;
            }

            update() {
                if (this.members.length === 0) return;

                // ØªØ­Ø¯ÙŠØ« Ù…Ø±ÙƒØ² Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©
                let sumX = 0, sumY = 0;
                this.members.forEach(member => {
                    sumX += member.x;
                    sumY += member.y;
                });
                this.center.x = sumX / this.members.length;
                this.center.y = sumY / this.members.length;
            }

            draw() {
                // Ø±Ø³Ù… Ø¯Ø§Ø¦Ø±Ø© Ø­ÙˆÙ„ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©
                ctx.strokeStyle = this.color;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(this.center.x, this.center.y, 60, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        // ÙØ¦Ø© Ø§Ù„Ø¹Ø¯Ùˆ Ø§Ù„Ù…Ø­Ø³Ù†Ø©
        class Enemy {
            constructor(type) {
                this.type = type;
                this.properties = enemyTypes[type];
                this.health = this.properties.health;
                this.maxHealth = this.properties.health;
                this.speed = this.properties.speed;
                this.color = this.properties.color;
                this.pathIndex = 0;
                this.x = path[0].x;
                this.y = path[0].y;
                this.group = null;
                this.effects = [];
                this.avoidCooldown = 0;
                
                // Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø³Ù„ÙˆÙƒ Ø§Ù„Ø®Ø§Øµ
                this.setupBehavior();
            }

            setupBehavior() {
                switch(this.properties.behavior) {
                    case 'avoid':
                        this.avoidRange = 120;
                        break;
                    case 'group':
                        this.findGroup();
                        break;
                    case 'mage':
                        this.slowAura = { range: 100, power: 0.3 };
                        break;
                    case 'boss':
                        this.fireCooldown = 0;
                        this.pullCooldown = 0;
                        break;
                }
            }

            findGroup() {
                // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù…Ø¬Ù…ÙˆØ¹Ø© Ù‚Ø±ÙŠØ¨Ø© Ø£Ùˆ Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¯ÙŠØ¯Ø©
                let closestGroup = null;
                let minDistance = Infinity;

                gameState.groups.forEach(group => {
                    const dx = group.center.x - this.x;
                    const dy = group.center.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < minDistance && group.members.length < 5) {
                        minDistance = distance;
                        closestGroup = group;
                    }
                });

                if (closestGroup && minDistance < 200) {
                    closestGroup.addMember(this);
                } else {
                    const newGroup = new Group();
                    newGroup.addMember(this);
                    gameState.groups.push(newGroup);
                }
            }

            update() {
                // ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªØ£Ø«ÙŠØ±Ø§Øª
                this.updateEffects();

                // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø³Ù„ÙˆÙƒÙŠØ§Øª Ø§Ù„Ø®Ø§ØµØ©
                this.applySpecialBehavior();

                // Ø§Ù„Ø­Ø±ÙƒØ© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³Ø§Ø±
                this.followPath();

                return this.health > 0;
            }

            applySpecialBehavior() {
                switch(this.properties.behavior) {
                    case 'avoid':
                        this.avoidTowers();
                        break;
                    case 'mage':
                        this.applySlowAura();
                        break;
                    case 'boss':
                        this.bossAbilities();
                        break;
                }
            }

            avoidTowers() {
                if (this.avoidCooldown > 0) {
                    this.avoidCooldown--;
                    return;
                }

                let closestTower = null;
                let minDistance = this.avoidRange;

                gameState.towers.forEach(tower => {
                    const dx = tower.x - this.x;
                    const dy = tower.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestTower = tower;
                    }
                });

                if (closestTower) {
                    // ØªØ¬Ù†Ø¨ Ø§Ù„Ø¨Ø±Ø¬
                    const angle = Math.atan2(this.y - closestTower.y, this.x - closestTower.x);
                    const avoidDistance = 50;
                    
                    this.x += Math.cos(angle) * 3;
                    this.y += Math.sin(angle) * 3;
                    
                    this.avoidCooldown = 30;
                }
            }

            applySlowAura() {
                gameState.towers.forEach(tower => {
                    const dx = tower.x - this.x;
                    const dy = tower.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < this.slowAura.range) {
                        // ØªØ·Ø¨ÙŠÙ‚ ØªØ£Ø«ÙŠØ± Ø§Ù„ØªØ¨Ø§Ø·Ø¤ Ø¹Ù„Ù‰ Ø§Ù„Ø¨Ø±Ø¬
                        tower.slowEffect = this.slowAura.power;
                    }
                });
            }

            bossAbilities() {
                // Ù‚Ø¯Ø±Ø© Ø¥Ø·Ù„Ø§Ù‚ Ø§Ù„Ù†Ø§Ø±
                this.fireCooldown--;
                if (this.fireCooldown <= 0) {
                    this.shootFireballs();
                    this.fireCooldown = 120;
                }

                // Ù‚Ø¯Ø±Ø© Ø§Ù„Ø¬Ø°Ø¨
                this.pullCooldown--;
                if (this.pullCooldown <= 0) {
                    this.pullTowers();
                    this.pullCooldown = 300;
                }
            }

            shootFireballs() {
                // Ø¥Ø·Ù„Ø§Ù‚ ÙƒØ±Ø§Øª Ù†Ø§Ø±ÙŠØ© Ù†Ø­Ùˆ Ø§Ù„Ø£Ø¨Ø±Ø§Ø¬
                gameState.towers.forEach(tower => {
                    if (Math.random() < 0.3) {
                        gameState.projectiles.push({
                            x: this.x,
                            y: this.y,
                            target: tower,
                            damage: 20,
                            color: '#FF4500',
                            speed: 3,
                            type: 'fireball'
                        });
                    }
                });
            }

            pullTowers() {
                // Ø¬Ø°Ø¨ Ø§Ù„Ø£Ø¨Ø±Ø§Ø¬ Ø§Ù„Ù‚Ø±ÙŠØ¨Ø©
                gameState.towers.forEach(tower => {
                    const dx = this.x - tower.x;
                    const dy = this.y - tower.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 200) {
                        const pullForce = 0.1;
                        tower.x += dx * pullForce;
                        tower.y += dy * pullForce;
                    }
                });
            }

            followPath() {
                const target = path[this.pathIndex + 1];
                if (!target) {
                    gameState.health -= this.type === 'boss' ? 20 : 10;
                    return;
                }

                const dx = target.x - this.x;
                const dy = target.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < this.speed) {
                    this.pathIndex++;
                } else {
                    this.x += (dx / distance) * this.speed;
                    this.y += (dy / distance) * this.speed;
                }
            }

            updateEffects() {
                this.effects = this.effects.filter(effect => {
                    effect.duration--;
                    if (effect.duration <= 0) return false;
                    
                    // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø¶Ø±Ø± Ø§Ù„Ù…Ø³ØªÙ…Ø±
                    if (effect.type === 'poison' && effect.duration % 30 === 0) {
                        this.health -= effect.damage;
                    }
                    
                    return true;
                });
            }

            draw() {
                // Ø±Ø³Ù… Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ø®Ø§Øµ Ø¨Ø§Ù„Ø¹Ø¯Ùˆ
                ctx.save();
                
                switch(this.properties.shape) {
                    case 'ghost':
                        this.drawGhost();
                        break;
                    case 'tank':
                        this.drawTank();
                        break;
                    case 'mage':
                        this.drawMage();
                        break;
                    case 'runner':
                        this.drawRunner();
                        break;
                    case 'dragon':
                        this.drawDragon();
                        break;
                    default:
                        this.drawBasic();
                }

                // Ø±Ø³Ù… Ø´Ø±ÙŠØ· Ø§Ù„ØµØ­Ø©
                this.drawHealthBar();
                
                ctx.restore();
            }

            drawGhost() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.properties.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // ØªØ£Ø«ÙŠØ± Ø§Ù„Ø´Ø¨Ø­
                ctx.globalAlpha = 0.6;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.properties.radius + 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }

            drawTank() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - 15, this.y - 10, 30, 20);
                
                // Ù…Ø¯ÙØ¹ Ø§Ù„Ø¯Ø¨Ø§Ø¨Ø©
                ctx.fillStyle = '#333';
                ctx.fillRect(this.x + 10, this.y - 3, 15, 6);
            }

            drawMage() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.properties.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // ØªØ£Ø«ÙŠØ± Ø³Ø­Ø±ÙŠ
                ctx.strokeStyle = '#FFFFFF';
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.properties.radius + 8, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            drawDragon() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.properties.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Ø£Ø¬Ù†Ø­Ø© Ø§Ù„ØªÙ†ÙŠÙ†
                ctx.fillStyle = '#8B0000';
                ctx.beginPath();
                ctx.ellipse(this.x - 15, this.y, 10, 20, Math.PI/4, 0, Math.PI * 2);
                ctx.ellipse(this.x + 15, this.y, 10, 20, -Math.PI/4, 0, Math.PI * 2);
                ctx.fill();
            }

            drawBasic() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.properties.radius, 0, Math.PI * 2);
                ctx.fill();
            }

            drawHealthBar() {
                const healthPercent = this.health / this.maxHealth;
                const barWidth = 30;
                const barHeight = 4;
                
                ctx.fillStyle = 'red';
                ctx.fillRect(this.x - barWidth/2, this.y - this.properties.radius - 10, barWidth, barHeight);
                ctx.fillStyle = healthPercent > 0.5 ? 'lime' : 'yellow';
                ctx.fillRect(this.x - barWidth/2, this.y - this.properties.radius - 10, barWidth * healthPercent, barHeight);
            }
        }

        // ÙØ¦Ø© Ø§Ù„Ø¨Ø±Ø¬ Ø§Ù„Ù…Ø­Ø³Ù†Ø©
        class Tower {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.properties = { ...towerTypes[type] };
                this.lastShot = 0;
                this.slowEffect = 1;
                this.level = 1;
            }

            draw() {
                ctx.fillStyle = this.properties.color;
                
                switch(this.properties.shape) {
                    case 'circle':
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, 15, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 'square':
                        ctx.fillRect(this.x - 12, this.y - 12, 24, 24);
                        break;
                    case 'triangle':
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y - 12);
                        ctx.lineTo(this.x - 10, this.y + 8);
                        ctx.lineTo(this.x + 10, this.y + 8);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case 'hexagon':
                        ctx.beginPath();
                        for (let i = 0; i < 6; i++) {
                            const angle = (i * 60) * Math.PI / 180;
                            const px = this.x + 12 * Math.cos(angle);
                            const py = this.y + 12 * Math.sin(angle);
                            if (i === 0) ctx.moveTo(px, py);
                            else ctx.lineTo(px, py);
                        }
                        ctx.closePath();
                        ctx.fill();
                        break;
                }

                // Ø±Ø³Ù… Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø¨Ø±Ø¬
                ctx.fillStyle = 'white';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.level, this.x, this.y + 4);
            }

            update() {
                const now = Date.now();
                if (now - this.lastShot > this.properties.speed * this.slowEffect) {
                    const target = this.findTarget();
                    if (target) {
                        this.shoot(target);
                        this.lastShot = now;
                    }
                }
            }

            findTarget() {
                let closestEnemy = null;
                let minDistance = this.properties.range;

                gameState.enemies.forEach(enemy => {
                    const dx = enemy.x - this.x;
                    const dy = enemy.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestEnemy = enemy;
                    }
                });

                return closestEnemy;
            }

            shoot(target) {
                const projectile = {
                    x: this.x,
                    y: this.y,
                    target: target,
                    damage: this.properties.damage,
                    color: this.properties.color,
                    speed: 5,
                    type: this.type
                };

                // Ø¥Ø¶Ø§ÙØ© ØªØ£Ø«ÙŠØ±Ø§Øª Ø®Ø§ØµØ©
                if (this.properties.slow) {
                    projectile.slow = this.properties.slow;
                }
                if (this.properties.dot) {
                    projectile.dot = { ...this.properties.dot };
                }

                gameState.projectiles.push(projectile);
            }
        }

        // Ø¯ÙˆØ±Ø© Ø§Ù„Ù„Ø¹Ø¨Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
        function gameLoop() {
            // Ø±Ø³Ù… Ø§Ù„Ø®Ù„ÙÙŠØ©
            ctx.fillStyle = '#2d5016';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Ø±Ø³Ù… Ø§Ù„Ù…Ø³Ø§Ø±
            drawPath();

            // ØªØ­Ø¯ÙŠØ« ÙˆØ¹Ø±Ø¶ Ø§Ù„Ø£Ø¨Ø±Ø§Ø¬
            gameState.towers.forEach(tower => {
                tower.update();
                tower.draw();
            });

            // ØªØ­Ø¯ÙŠØ« ÙˆØ¹Ø±Ø¶ Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const enemy = gameState.enemies[i];
                if (!enemy.update()) {
                    if (enemy.health <= 0) {
                        gameState.gold += enemy.properties.gold;
                    }
                    gameState.enemies.splice(i, 1);
                } else {
                    enemy.draw();
                }
            }

            // ØªØ­Ø¯ÙŠØ« ÙˆØ¹Ø±Ø¶ Ø§Ù„Ù‚Ø°Ø§Ø¦Ù
            for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                const projectile = gameState.projectiles[i];
                if (!updateProjectile(projectile)) {
                    gameState.projectiles.splice(i, 1);
                } else {
                    drawProjectile(projectile);
                }
            }

            // ØªØ­Ø¯ÙŠØ« ÙˆØ¹Ø±Ø¶ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª
            gameState.groups.forEach(group => {
                group.update();
                group.draw();
            });

            // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª Ø§Ù„ÙØ§Ø±ØºØ©
            gameState.groups = gameState.groups.filter(group => group.members.length > 0);

            // ØªÙˆÙ„ÙŠØ¯ Ø£Ø¹Ø¯Ø§Ø¡ Ø¬Ø¯Ø¯
            spawnEnemies();

            requestAnimationFrame(gameLoop);
        }

        function drawPath() {
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 40;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i < path.length; i++) {
                ctx.lineTo(path[i].x, path[i].y);
            }
            ctx.stroke();
        }

        function updateProjectile(projectile) {
            const dx = projectile.target.x - projectile.x;
            const dy = projectile.target.y - projectile.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < projectile.speed) {
                // Ø¥ØµØ§Ø¨Ø© Ø§Ù„Ù‡Ø¯Ù
                projectile.target.health -= projectile.damage;
                
                // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªØ£Ø«ÙŠØ±Ø§Øª Ø§Ù„Ø®Ø§ØµØ©
                if (projectile.slow) {
                    projectile.target.speed *= projectile.slow;
                }
                if (projectile.dot) {
                    projectile.target.effects.push({
                        type: 'poison',
                        damage: projectile.dot.damage,
                        duration: projectile.dot.duration
                    });
                }

                return false;
            }

            projectile.x += (dx / distance) * projectile.speed;
            projectile.y += (dy / distance) * projectile.speed;
            return true;
        }

        function drawProjectile(projectile) {
            ctx.fillStyle = projectile.color;
            ctx.beginPath();
            ctx.arc(projectile.x, projectile.y, 4, 0, Math.PI * 2);
            ctx.fill();
        }

        function spawnEnemies() {
            if (!gameState.isWaveActive) return;

            if (gameState.enemiesSpawned < gameState.enemiesInWave) {
                if (Math.random() < 0.02) {
                    const enemyTypes = ['ghost', 'tank', 'mage', 'runner'];
                    const weights = [0.3, 0.2, 0.2, 0.3]; // Ø£ÙˆØ²Ø§Ù† Ø§Ù„Ø¸Ù‡ÙˆØ±
                    
                    let random = Math.random();
                    let typeIndex = 0;
                    let weightSum = 0;
                    
                    for (let i = 0; i < weights.length; i++) {
                        weightSum += weights[i];
                        if (random <= weightSum) {
                            typeIndex = i;
                            break;
                        }
                    }

                    gameState.enemies.push(new Enemy(enemyTypes[typeIndex]));
                    gameState.enemiesSpawned++;
                }
            }

            // Ø¸Ù‡ÙˆØ± Ø§Ù„Ø²Ø¹ÙŠÙ… ÙƒÙ„ 5 Ù…ÙˆØ¬Ø§Øª
            if (gameState.wave % 5 === 0 && !gameState.bossSpawned && gameState.enemiesSpawned >= gameState.enemiesInWave * 0.7) {
                gameState.enemies.push(new Enemy('boss'));
                gameState.bossSpawned = true;
                bossWarning.style.display = 'block';
                
                setTimeout(() => {
                    bossWarning.style.display = 'none';
                }, 5000);
            }
        }

        // Ø¥Ø¶Ø§ÙØ© Ù…Ø³ØªÙ…Ø¹ÙŠ Ø§Ù„Ø£Ø­Ø¯Ø§Ø«
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Ø¨Ù†Ø§Ø¡ Ø¨Ø±Ø¬ Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ù„Ù„Ù…Ø«Ø§Ù„
            const towerTypes = ['arrow', 'cannon', 'ice', 'poison'];
            const randomType = towerTypes[Math.floor(Math.random() * towerTypes.length)];
            
            gameState.towers.push(new Tower(x, y, randomType));
        });

        document.getElementById('startWave').addEventListener('click', () => {
            gameState.isWaveActive = true;
            gameState.enemiesSpawned = 0;
            gameState.bossSpawned = false;
            gameState.enemiesInWave = 8 + gameState.wave * 2;
            gameState.wave++;
        });

        document.getElementById('restartGame').addEventListener('click', () => {
            gameState.towers = [];
            gameState.enemies = [];
            gameState.projectiles = [];
            gameState.groups = [];
            gameState.wave = 1;
            gameState.health = 100;
            gameState.gold = 200;
            gameState.isWaveActive = false;
        });

        // Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©
        gameLoop();
    </script>
</body>
</html>
